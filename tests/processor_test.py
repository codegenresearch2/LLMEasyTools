import pytest\\nfrom pydantic import BaseModel\\nfrom typing import Optional\\nfrom llm_easy_tools.types import SimpleMessage, SimpleToolCall, SimpleFunction, SimpleChoice, SimpleCompletion\\nfrom llm_easy_tools.processor import process_tool_call, ToolResult\\nfrom llm_easy_tools import LLMFunction\\nfrom concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor\\n\\ndef test_process_methods():\\n    class TestTool:\\n        def tool_method(self, arg: int) -> str:\\n            return f'executed tool_method with param: {arg}'\\n\\n        def no_output(self, arg: int):\\n            pass\\n\\n        def failing_method(self, arg: int) -> str:\\n            raise Exception('Some exception')\\n\\n    tool = TestTool()\\n    tool_call = mk_tool_call("tool_method", {"arg": 2})\\n    result = process_tool_call(tool_call, [tool.tool_method])\\n    assert isinstance(result, ToolResult)\\n    assert result.output == 'executed tool_method with param: 2'\\n    tool_call = mk_tool_call("failing_method", {"arg": 2})\\n    result = process_tool_call(tool_call, [tool.failing_method])\\n    assert isinstance(result, ToolResult)\\n    assert "Some exception" in str(result.error)\\n    message = result.to_message()\\n    assert "Some exception" in message['content']\\n    tool_call = mk_tool_call("no_output", {"arg": 2})\\n    result = process_tool_call(tool_call, [tool.no_output])\\n    assert isinstance(result, ToolResult)\\n    message = result.to_message()\\n    assert message['content'] == ''\\n\\ndef test_process_complex():\\n    class Address(BaseModel):\\n        street: str\\n        city: str\\n    class Company(BaseModel):\\n        name: str\\n        speciality: str\\n        address: Address\\n    def print_companies(companies: list[Company]):\\n        return companies\\n    company_list = [{\"address\": {\"city\": \"Metropolis\", \"street\": \"150 Futura Plaza\"},\\n        \"name\": \"Aether Innovations\", \"speciality\": \"sustainable energy solutions\"}]\\n    tool_call = mk_tool_call("print_companies", {"companies": company_list})\\n    result = process_tool_call(tool_call, [print_companies])\\n    assert isinstance(result, ToolResult)\\n    assert isinstance(result.output, list)\\n    assert isinstance(result.output[0], Company)\\n\\ndef test_prefixing():\\n    class Reflection(BaseModel):\\n        relevancy: str\\n    args = {'relevancy': 'good', 'name': 'hammer'}\\n    prefix = _extract_prefix_unpacked(args, Reflection)\\n    assert isinstance(prefix, Reflection)\\n    assert 'reflection' not in args\\n\\ndef test_json_fix():\\n    class UserDetail(BaseModel):\\n        name: str\\n        age: int\\n    original_user = UserDetail(name="John", age=21)\\n    json_data = json.dumps(original_user.model_dump())\\n    json_data = json_data[:-1] + ',}'\\n    tool_call = mk_tool_call_jason("UserDetail", json_data)\\n    result = process_tool_call(tool_call, [UserDetail])\\n    assert result.output == original_user\\n    assert len(result.soft_errors) > 0\\n    result = process_tool_call(tool_call, [UserDetail], fix_json_args=False)\\n    assert isinstance(result.error, json.decoder.JSONDecodeError)\\n\\ndef test_list_in_string_fix():\\n    class User(BaseModel):\\n        names: Optional[list[str]]\\n    tool_call = mk_tool_call("User", {"names": "John, Doe"})\\n    result = process_tool_call(tool_call, [User])\\n    assert result.output.names == ["John", "Doe"]\\n    assert len(result.soft_errors) > 0\\n    result = process_tool_call(tool_call, [User], fix_json_args=False)\\n    assert isinstance(result.error, ValidationError)\\n\\ndef test_case_insensitivity():\\n    class User(BaseModel):\\n        name: str\\n        city: str\\n    response = mk_chat_completion([mk_tool_call("user", {"name": "John", "city": "Metropolis"})])\\n    results = process_response(response, [User], case_insensitive=True)\\n    assert results[0].output == User(name="John", city="Metropolis")\\n\\ndef test_parallel_tools():\\n    class CounterClass():\\n        def __init__(self):\\n            self.counter = 0\\n        def increment_counter(self):\\n            self.counter += 1\\n            sleep(1)\\n    counter = CounterClass()\\n    tool_call = mk_tool_call("increment_counter", {})\\n    response = mk_chat_completion([tool_call] * 10)\\n    executor = ThreadPoolExecutor()\\n    start_time = time()\\n    results = process_response(response, [counter.increment_counter], executor=executor)\\n    end_time = time()\\n    assert results[9].error is None\\n    time_taken = end_time - start_time\\n    assert counter.counter == 10\\n    assert time_taken <= 3, f"Expected processing time to be less than or equal to 3 seconds, but was {time_taken}"\\n\\ndef test_process_one_tool_call():\\n    class User(BaseModel):\\n        name: str\\n        age: int\\n    response = mk_chat_completion([mk_tool_call("User", {"name": "Alice", "age": 30}), mk_tool_call("User", {"name": "Bob", "age": 25})])\\n    result = process_one_tool_call(response, [User], index=0)\\n    assert isinstance(result, ToolResult)\\n    assert result.output == User(name="Alice", age=30)\\n    result = process_one_tool_call(response, [User], index=1)\\n    assert isinstance(result, ToolResult)\\n    assert result.output == User(name="Bob", age=25)\\n    result = process_one_tool_call(response, [User], index=2)\\n    assert result is None\\n    invalid_response = mk_chat_completion([mk_tool_call("InvalidFunction", {})])\\n    result = process_one_tool_call(invalid_response, [User])\\n    assert isinstance(result, ToolResult)\\n    assert result.error is not None\\n