import json\nfrom time import sleep, time\nfrom unittest.mock import Mock\nfrom pydantic import BaseModel\nfrom typing import Optional, Any\nfrom llm_easy_tools.types import SimpleMessage, SimpleToolCall, SimpleFunction, SimpleChoice, SimpleCompletion\nfrom llm_easy_tools.processor import process_tool_call, ToolResult, process_response, process_one_tool_call\nfrom llm_easy_tools import LLMFunction\nfrom concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor\n\n\ndef mk_tool_call(name, args):\n    arguments = json.dumps(args)\n    return SimpleToolCall(id='A', function=SimpleFunction(name=name, arguments=arguments), type='function')\n\n\ndef mk_tool_call_jason(name, args):\n    return SimpleToolCall(id='A', function=SimpleFunction(name=name, arguments=args), type='function')\n\n\ndef mk_chat_completion(tool_calls):\n    return SimpleCompletion(\n        id='A',\n        created=0,\n        model='gpt-3.5-turbo',\n        object='chat.completion',\n        choices=[\n            SimpleChoice(\n                finish_reason='stop',\n                index=0,\n                message=SimpleMessage(role='assistant', tool_calls=tool_calls))\n        ]\n    )\n\n\nclass TestTool:\n    def tool_method(self, arg: int) -> str:\n        return f'executed tool_method with param: {arg}'\n\n    def no_output(self, arg: int):\n        pass\n\n    def failing_method(self, arg: int) -> str:\n        raise Exception('Some exception')\n\n\nclass UserDetail(BaseModel):\n    name: str\n    age: int\n\n\nclass Company(BaseModel):\n    name: str\n    speciality: str\n    address: Any\n\n\ndef print_companies(companies: list[Company]):\n    return companies\n\n\ndef test_process_methods():\n    tool = TestTool()\n    tool_call = mk_tool_call('tool_method', {'arg': 2})\n    result = process_tool_call(tool_call, [tool.tool_method])\n    assert isinstance(result, ToolResult)\n    assert result.output == 'executed tool_method with param: 2'\n\n    tool_call = mk_tool_call('failing_method', {'arg': 2})\n    result = process_tool_call(tool_call, [tool.failing_method])\n    assert isinstance(result, ToolResult)\n    assert 'Some exception' in str(result.error)\n    message = result.to_message()\n    assert 'Some exception' in message['content']\n\n    tool_call = mk_tool_call('no_output', {'arg': 2})\n    result = process_tool_call(tool_call, [tool.no_output])\n    assert isinstance(result, ToolResult)\n    message = result.to_message()\n    assert message['content'] == ''\n\n\ndef test_process_complex():\n    address = {'street': '150 Futura Plaza', 'city': 'Metropolis'}\n    company = {'name': 'Aether Innovations', 'speciality': 'sustainable energy solutions', 'address': address}\n    companies = [company]\n    tool_call = mk_tool_call('print_companies', {'companies': companies})\n    result = process_tool_call(tool_call, [print_companies])\n    assert isinstance(result, ToolResult)\n    assert isinstance(result.output, list)\n    assert isinstance(result.output[0], Company)\n\n\ndef test_process_one_tool_call():\n    response = mk_chat_completion([mk_tool_call('tool_method', {'arg': 2}), mk_tool_call('no_output', {'arg': 2})])\n    result = process_one_tool_call(response, [TestTool().tool_method], index=0)\n    assert isinstance(result, ToolResult)\n    assert result.output == 'executed tool_method with param: 2'\n    result = process_one_tool_call(response, [TestTool().no_output], index=1)\n    assert isinstance(result, ToolResult)\n    message = result.to_message()\n    assert message['content'] == ''\n